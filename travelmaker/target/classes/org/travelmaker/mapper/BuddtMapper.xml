<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
 PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
 "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="org.travelmaker.mapper.BuddtMapper">

<resultMap type="org.travelmaker.domain.BuddtVO" id="UserResult">
	<result property="paydate" column="pay_date"/>
	<result property="schno" column="sch_no"/>
	<result property="store" column="store"/>
	<result property="expense" column="expense"/>
	<result property="budcate" column="bud_cate"/>
	<result property="no" column="no"/>
</resultMap>

<select id="getList" resultMap="UserResult"> <!-- forEach로 출력합니다. CDATA는 부등호를 사용하기 위함 입니다.-->
<![CDATA[ 
select * from bud_dt where no > 0
]]> 
</select>

<select id="cateCnt" resultMap="UserResult"> <!-- 카테고리와 카테고리 별로 해당되는 행을 카운트 할 것입니다. -->
select bud_cate, count(*) as cate_cnt from bud_dt group by bud_cate
</select>
<!-- select bud_cate, pay_date, count(*) as cate_cnt from bud_dt where pay_date = #{paydate} group by bud_cate, pay_date -->

<insert id="insert">
insert into bud_dt ( pay_date, sch_no, store, expense, bud_cate, no)
values ( #{paydate}, #{schno}, #{store}, #{expense}, #{budcate}, seq_no.nextval)
</insert>

<select id="box" resultMap="UserResult">
select distinct sch_no from bud_dt
</select>

<select id="dateBox" resultMap="UserResult">
SELECT DISTINCT pay_date FROM bud_dt
</select>

<select id="mmDate" resultMap="UserResult">
SELECT MAX(pay_date) as maxDate, MIN(pay_date) as minDate
FROM bud_dt
WHERE sch_no = #{schno}
</select>
<!-- <insert id="insertSelectKey">

  <selectKey keyProperty="sch_no" order="BEFORE"
    resultType="long">
    select sch_no from dual
  </selectKey>

insert into schedule (sch_no, mem_no, sch_title, from_date, to_date, img, sch_reg_date, sch_last_date, sch_status, memo, sch_region)
values (#{schno}, #{mem_no}, #{sch_title}, #{from_date},#{img}, #{sch_reg_date}, #{sch_last_date}, #{sch_status}, #{memo}, #{sch_region})
</insert>  -->

<select id="read" resultMap="UserResult">
<!-- select * from bud_dt where pay_date=#{paydate} order by no asc -->
select pay_date, no, store, sch_no, trim(TO_CHAR(sum(expense), '999,999,999')) as expense, bud_cate
from bud_dt 
where pay_date = #{paydate}
group by no, pay_date, store, sch_no, bud_cate
order by no asc
</select>

<select id="readed" resultMap="UserResult">
<!-- select * from bud_dt where pay_date=#{paydate} order by no asc -->
select * 
from bud_dt
where no= #{no} and pay_date =#{paydate} and sch_no= #{schno} 
</select>

<select id="readAll" resultMap="UserResult">
<!-- select * from bud_dt where pay_date=#{paydate} order by no asc -->
select pay_date, no, store, sch_no, trim(TO_CHAR(sum(expense), '999,999,999')) as expense, bud_cate
from bud_dt 
where sch_no = #{schno}
group by no, pay_date, store, sch_no, bud_cate
order by pay_date asc
</select>

<delete id="delete" >
delete from bud_dt where no = #{no}
</delete>

<update id="update">
update bud_dt
set sch_no = #{schno},
pay_date = #{paydate},
store = #{store},
expense = #{expense},
bud_cate = #{budcate}
where no = #{no}
</update>

</mapper>